const std = @import("std");
const gitweb = @import("gitweb.zig");
const main = @import("main.zig");
const git = @import("git.zig");

pub fn writeHeader(ctx: *gitweb.Context, writer: anytype) !void {
    if (ctx.cfg.noheader) {
        return;
    }

    try writer.writeAll("<!DOCTYPE html>\n");
    try writer.writeAll("<html lang='en'>\n");
    try writer.writeAll("<head>\n");
    try writer.print("<meta charset='{s}'/>\n", .{ctx.page.charset});
    try writer.writeAll("<meta name='viewport' content='width=device-width, initial-scale=1'/>\n");
    try writer.print("<title>{s}</title>\n", .{ctx.page.title});
    try writer.print("<link rel='stylesheet' type='text/css' href='{s}'/>\n", .{ctx.cfg.css});

    if (ctx.cfg.favicon.len > 0) {
        try writer.print("<link rel='shortcut icon' href='{s}'/>\n", .{ctx.cfg.favicon});
    }

    // Add Atom feed link if we're viewing a repository
    if (ctx.repo) |repo| {
        try writer.print("<link rel='alternate' type='application/atom+xml' title='{s} Atom Feed' href='?r={s}&cmd=atom", .{ repo.name, repo.name });
        // Include branch if specified
        if (ctx.query.get("h")) |branch| {
            try writer.print("&h={s}", .{branch});
        }
        try writer.writeAll("'/>\n");
    }

    if (ctx.cfg.head_include) |include| {
        try includeFile(writer, include);
    }

    // Include Chart.js if on stats page
    if (std.mem.eql(u8, ctx.cmd, "stats")) {
        try writer.writeAll("<script type='text/javascript' src='/chart.js'></script>\n");
    }

    try writer.writeAll("</head>\n");
    try writer.writeAll("<body>\n");

    // Header section
    try writer.writeAll("<div id='gitweb'>\n");
    try writer.writeAll("<table id='header'>\n");
    try writer.writeAll("<tr>\n");
    try writer.writeAll("<td class='logo' rowspan='2'>");
    try writer.print("<a href='{s}'><img src='{s}' alt='gitweb logo'/></a>", .{ ctx.cfg.logo_link, ctx.cfg.logo });
    try writer.writeAll("</td>\n");

    // Show repository path if we're viewing a specific repository
    if (ctx.repo) |repo| {
        try writer.writeAll("<td class='main'>");
        try writer.print("<a href='{s}'>index</a> : {s}", .{ ctx.cfg.virtual_root, repo.name });
        try writer.writeAll("</td>\n");
        try writer.writeAll("</tr>\n");
        try writer.writeAll("<tr><td class='sub'>");
        if (repo.desc.len > 0) {
            try htmlEscape(writer, repo.desc);
        } else {
            try writer.writeAll("&nbsp;");
        }
        try writer.writeAll("</td></tr>\n");
    } else {
        // Main index page - show the site title
        try writer.print("<td class='main'><a href='{s}'>{s}</a></td>", .{ ctx.cfg.virtual_root, ctx.cfg.root_title });
        try writer.writeAll("</tr>\n");
        try writer.writeAll("<tr><td class='sub'>");
        try writer.writeAll(ctx.cfg.root_desc);
        try writer.writeAll("</td></tr>\n");
    }

    try writer.writeAll("</table>\n");

    // Navigation tabs and branch selector
    if (ctx.repo) |repo| {
        try writeRepoTabs(ctx, repo, writer);
        try writeBranchSelector(ctx, repo, writer);
    }

    try writer.writeAll("<div class='content'>\n");
}

pub fn writeFooter(ctx: *gitweb.Context, writer: anytype) !void {
    if (ctx.cfg.noheader) {
        return;
    }

    try writer.writeAll("</div>\n");

    if (ctx.cfg.footer) |footer| {
        try writer.writeAll("<div class='footer'>");
        try includeFile(writer, footer);
        try writer.writeAll("</div>\n");
    } else {
        try writer.writeAll("<div class='footer'>generated by ");
        try writer.print("<a href='https://github.com/mrjbq7/zig-gitweb'>zig-gitweb {s}</a>", .{main.version});
        try writer.writeAll(" at ");

        // Get current time and format it properly
        const timestamp = std.time.timestamp();

        // Use the same formatting function we use elsewhere
        const parsing = @import("parsing.zig");
        try parsing.formatTimestamp(@intCast(timestamp), writer);
        try writer.writeAll(" UTC");

        // Calculate and show generation time
        const end_time = std.time.nanoTimestamp();
        const duration_ns = end_time - ctx.start_time;
        const duration_ms = @divFloor(duration_ns, 1_000_000);

        try writer.print(" ({d}ms)", .{duration_ms});
        try writer.writeAll("</div>\n");
    }

    try writer.writeAll("</div>\n");
    try writer.writeAll("</body>\n");
    try writer.writeAll("</html>\n");
}

fn writeRepoTabs(ctx: *gitweb.Context, repo: *gitweb.Repo, writer: anytype) !void {
    try writer.writeAll("<table class='tabs'><tr><td>\n");

    const current_branch = ctx.query.get("h");
    const current_path = ctx.query.get("path");

    // Summary tab
    try writeTab(writer, "summary", "summary", ctx.cmd, repo.name, current_branch, null);

    // Branches tab
    try writeTab(writer, "branches", "branches", ctx.cmd, repo.name, current_branch, null);

    // Tags tab
    try writeTab(writer, "tags", "tags", ctx.cmd, repo.name, current_branch, null);

    // Log tab - preserve path if present
    try writeTab(writer, "log", "log", ctx.cmd, repo.name, current_branch, current_path);

    // Tree tab - preserve path if present
    try writeTab(writer, "tree", "tree", ctx.cmd, repo.name, current_branch, current_path);

    // Commit tab
    try writeTab(writer, "commit", "commit", ctx.cmd, repo.name, current_branch, null);

    // Diff tab
    try writeTab(writer, "diff", "diff", ctx.cmd, repo.name, current_branch, null);

    // Stats tab
    if (repo.max_stats != null) {
        try writeTab(writer, "stats", "stats", ctx.cmd, repo.name, current_branch, null);
    }

    // Search tab
    try writeTab(writer, "search", "search", ctx.cmd, repo.name, current_branch, null);

    try writer.writeAll("</td></tr></table>\n");
}

fn writeTab(writer: anytype, name: []const u8, cmd: []const u8, current_cmd: []const u8, repo_name: []const u8, branch: ?[]const u8, path: ?[]const u8) !void {
    if (std.mem.eql(u8, cmd, current_cmd)) {
        try writer.print("<a class='active' href='?r={s}&cmd={s}", .{ repo_name, cmd });
        if (branch) |b| {
            try writer.print("&h={s}", .{b});
        }
        if (path) |p| {
            try writer.writeAll("&path=");
            try urlEncodePath(writer, p);
        }
        try writer.print("'>{s}</a>", .{name});
    } else {
        try writer.print("<a href='?r={s}&cmd={s}", .{ repo_name, cmd });
        if (branch) |b| {
            try writer.print("&h={s}", .{b});
        }
        if (path) |p| {
            try writer.writeAll("&path=");
            try urlEncodePath(writer, p);
        }
        try writer.print("'>{s}</a>", .{name});
    }
}

fn writeBranchSelector(ctx: *gitweb.Context, repo: *gitweb.Repo, writer: anytype) !void {
    try writer.writeAll("<div class='branch-selector'>\n");
    try writer.writeAll("<form method='get' action=''>\n");

    // Include hidden fields for current parameters
    try writer.print("<input type='hidden' name='r' value='{s}' />\n", .{repo.name});

    // For tag page, switching branches should go to summary page
    if (std.mem.eql(u8, ctx.cmd, "tag")) {
        try writer.writeAll("<input type='hidden' name='cmd' value='summary' />\n");
    } else if (ctx.cmd.len > 0) {
        try writer.print("<input type='hidden' name='cmd' value='{s}' />\n", .{ctx.cmd});
    }

    // Get current branch from query or use HEAD
    // On tag page, h parameter is the tag name, so we don't select it in the branch list
    const current_branch = if (std.mem.eql(u8, ctx.cmd, "tag"))
        "HEAD" // Default to HEAD when viewing tags
    else
        ctx.query.get("h") orelse "HEAD";

    try writer.writeAll("<label for='branch-select'>Branch: </label>\n");
    try writer.writeAll("<select name='h' id='branch-select' onchange='this.form.submit()'>\n");

    // Open repository to get branches
    var git_repo = git.Repository.open(repo.path) catch {
        try writer.writeAll("<option value='HEAD'>HEAD</option>\n");
        try writer.writeAll("</select>\n");
        try writer.writeAll("</form>\n");
        try writer.writeAll("</div>\n");
        return;
    };
    defer git_repo.close();

    // Add HEAD option
    if (std.mem.eql(u8, current_branch, "HEAD")) {
        try writer.writeAll("<option value='HEAD' selected>HEAD</option>\n");
    } else {
        try writer.writeAll("<option value='HEAD'>HEAD</option>\n");
    }

    // Get and list branches
    const branches = git_repo.getBranches(ctx.allocator) catch {
        try writer.writeAll("</select>\n");
        try writer.writeAll("</form>\n");
        try writer.writeAll("</div>\n");
        return;
    };
    defer ctx.allocator.free(branches);

    for (branches) |branch| {
        if (!branch.is_remote) {
            defer @constCast(&branch.ref).free();

            if (std.mem.eql(u8, current_branch, branch.name)) {
                try writer.print("<option value='{s}' selected>{s}</option>\n", .{ branch.name, branch.name });
            } else {
                try writer.print("<option value='{s}'>{s}</option>\n", .{ branch.name, branch.name });
            }
        }
    }

    try writer.writeAll("</select>\n");
    try writer.writeAll(" <input type='submit' value='Switch' />\n");
    try writer.writeAll("</form>\n");
    try writer.writeAll("</div>\n");
}

fn includeFile(writer: anytype, path: []const u8) !void {
    const file = std.fs.openFileAbsolute(path, .{}) catch {
        return; // Silently fail if include file doesn't exist
    };
    defer file.close();

    const content = file.readToEndAlloc(std.heap.page_allocator, std.math.maxInt(usize)) catch {
        return;
    };
    defer std.heap.page_allocator.free(content);

    try writer.writeAll(content);
}

pub fn htmlEscape(writer: anytype, text: []const u8) !void {
    for (text) |char| {
        switch (char) {
            '<' => try writer.writeAll("&lt;"),
            '>' => try writer.writeAll("&gt;"),
            '&' => try writer.writeAll("&amp;"),
            '"' => try writer.writeAll("&quot;"),
            '\'' => try writer.writeAll("&#39;"),
            else => try writer.writeByte(char),
        }
    }
}

pub fn urlEncode(writer: anytype, text: []const u8) !void {
    for (text) |char| {
        if (std.ascii.isAlphanumeric(char) or char == '-' or char == '_' or char == '.' or char == '~') {
            try writer.writeByte(char);
        } else {
            try writer.print("%{X:0>2}", .{char});
        }
    }
}

pub fn urlEncodePath(writer: anytype, text: []const u8) !void {
    // Like urlEncode but keeps forward slashes unencoded for readability
    for (text) |char| {
        if (std.ascii.isAlphanumeric(char) or char == '-' or char == '_' or char == '.' or char == '~' or char == '/') {
            try writer.writeByte(char);
        } else {
            try writer.print("%{X:0>2}", .{char});
        }
    }
}

pub fn urlDecode(allocator: std.mem.Allocator, text: []const u8) ![]u8 {
    var result = std.ArrayList(u8){
        .items = &.{},
        .capacity = 0,
    };
    defer result.deinit(allocator);

    var i: usize = 0;
    while (i < text.len) {
        if (text[i] == '%' and i + 2 < text.len) {
            // Try to parse the next two characters as hex
            const hex_str = text[i + 1 .. i + 3];
            if (std.fmt.parseInt(u8, hex_str, 16)) |byte| {
                try result.append(allocator, byte);
                i += 3;
            } else |_| {
                // Not valid hex, just append the % character
                try result.append(allocator, text[i]);
                i += 1;
            }
        } else if (text[i] == '+') {
            // + is encoded space in query strings
            try result.append(allocator, ' ');
            i += 1;
        } else {
            try result.append(allocator, text[i]);
            i += 1;
        }
    }

    return result.toOwnedSlice(allocator);
}

pub fn writeLink(writer: anytype, url: []const u8, text: []const u8) !void {
    try writer.print("<a href='{s}'>", .{url});
    try htmlEscape(writer, text);
    try writer.writeAll("</a>");
}

pub fn writeTableHeader(writer: anytype, headers: []const []const u8) !void {
    try writer.writeAll("<table class='list'>\n");
    try writer.writeAll("<tr class='nohover'>");
    for (headers) |header| {
        try writer.print("<th>{s}</th>", .{header});
    }
    try writer.writeAll("</tr>\n");
}

pub fn writeTableRow(writer: anytype, class: ?[]const u8) !void {
    if (class) |c| {
        try writer.print("<tr class='{s}'>", .{c});
    } else {
        try writer.writeAll("<tr>");
    }
}

pub fn writeTableCell(writer: anytype, class: ?[]const u8, content: []const u8) !void {
    if (class) |c| {
        try writer.print("<td class='{s}'>", .{c});
    } else {
        try writer.writeAll("<td>");
    }
    try htmlEscape(writer, content);
    try writer.writeAll("</td>");
}

pub fn writeTableFooter(writer: anytype) !void {
    try writer.writeAll("</table>\n");
}

// Tests
const testing = std.testing;

test htmlEscape {
    const allocator = testing.allocator;
    var list: std.ArrayList(u8) = .empty;
    defer list.deinit(allocator);

    // Test basic HTML escaping
    try htmlEscape(list.writer(allocator), "<script>alert('xss')</script>");
    try testing.expectEqualStrings("&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;", list.items);

    // Test with quotes
    list.clearRetainingCapacity();
    try htmlEscape(list.writer(allocator), "\"quoted\" & 'text'");
    try testing.expectEqualStrings("&quot;quoted&quot; &amp; &#39;text&#39;", list.items);
}

test urlEncode {
    const allocator = testing.allocator;
    var list: std.ArrayList(u8) = .empty;
    defer list.deinit(allocator);

    // Test URL encoding with spaces and special chars
    try urlEncode(list.writer(allocator), "hello world & stuff");
    try testing.expectEqualStrings("hello%20world%20%26%20stuff", list.items);

    // Test with path separator
    list.clearRetainingCapacity();
    try urlEncode(list.writer(allocator), "path/to/file");
    try testing.expectEqualStrings("path%2Fto%2Ffile", list.items);
}

test urlEncodePath {
    const allocator = testing.allocator;
    var list: std.ArrayList(u8) = .empty;
    defer list.deinit(allocator);

    // Path encoding preserves slashes
    try urlEncodePath(list.writer(allocator), "path/to/file with spaces");
    try testing.expectEqualStrings("path/to/file%20with%20spaces", list.items);
}

test urlDecode {
    const allocator = testing.allocator;

    // Test basic URL decoding
    const decoded1 = try urlDecode(allocator, "hello%20world");
    defer allocator.free(decoded1);
    try testing.expectEqualStrings("hello world", decoded1);

    // Test with multiple encoded chars
    const decoded2 = try urlDecode(allocator, "a%2Bb%3Dc");
    defer allocator.free(decoded2);
    try testing.expectEqualStrings("a+b=c", decoded2);

    // Test with plus as space
    const decoded3 = try urlDecode(allocator, "hello+world");
    defer allocator.free(decoded3);
    try testing.expectEqualStrings("hello world", decoded3);
}
